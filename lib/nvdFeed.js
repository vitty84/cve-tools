/**
 * @fileOverview Functions for working with the NVD feed of CVE advisories.
 *
 * This is basically a matter of obtaining and parsing XML. Yay. See:
 * https://nvd.nist.gov/download.cfm
 */

// Core.
var path = require('path');
var util = require('util');
var zlib = require('zlib');

// NPM.
var async = require('async');
var fs = require('fs-extra');
var libxmljs = require('libxmljs');
var request = require('request');

// -------------------------------------------------------------------------
// Variables.
// -------------------------------------------------------------------------

var localDataDir = path.resolve(__dirname, '../data');

// This will be constructed; libxmljs docs indexed by year.
exports.xmlByYear = {};
// This will be constructed; data indexed by CVE ID.
exports.cveData = {};

// -------------------------------------------------------------------------
// File and path stuff.
// -------------------------------------------------------------------------

/**
 * Get the year from the CVE ID.
 *
 * @param {String} cveId The CVE ID, e.g. CVE-2002-0001.
 * @return {Number} The year.
 */
exports.yearFromCveId = function (cveId) {
  var match = /CVE-(\d+)-\d+/.exec(cveId);

  if (match) {
    return parseInt(match[1], 10);
  }
  else {
    return NaN;
  }
};

/**
 * Return the file name for the NVD feed for a given year of vulnerabilities.
 *
 * @param {Number} year The year of the data.
 * @return {String} The filename.
 */
exports.getFeedFileName = function (year) {
  return util.format(
    'nvdcve-2.0-%d.xml',
    year
  );
};

/**
 * Return the URL for the NVD feed for a given year of vulnerabilities.
 *
 * @param {Number} year The year of the data.
 * @return {String} The URL.
 */
exports.getFeedUrl = function (year) {
  return util.format(
    'https://nvd.nist.gov/feeds/xml/cve/%s.gz',
    exports.getFeedFileName(year)
  );
};

/**
 * Return the local path for the NVD feed for a given year of vulnerabilities.
 *
 * @param {Number} year The year of the data.
 * @return {String} The URL.
 */
exports.getLocalFeedFilePath = function (year) {
  return path.resolve(localDataDir, exports.getFeedFileName(year));
};

/**
 * Obtain the URL for a specific CVE.
 *
 * @param {String} cveId The CVE ID, e.g. CVE-2002-0001.
 * @return {String} The URL.
 */
exports.getCveUrl = function (cveId) {
  return 'https://web.nvd.nist.gov/view/vuln/detail?vulnId=' + cveId;
};

// -------------------------------------------------------------------------
// Fetching content.
// -------------------------------------------------------------------------

/**
 * Load the full year data as an XML string from the local cache or the
 * NVD site.
 *
 * Write it to a local file.
 *
 * @param {Number} year The year of the data.
 * @param {Function} callback Of the form function (error).
 */
exports.downloadYearData = function (year, callback) {
  var filePath = exports.getLocalFeedFilePath(year);
  var retryLimit = 3;

  async.retry(retryLimit, function (asyncCallback) {
    var buffers = [];
    var req = request.get(
      exports.getFeedUrl(year),
      function (error, response) {
        if (error) {
          return asyncCallback(error);
        }
        else if (response.statusCode < 200 || response.statusCode >= 300) {
          return asyncCallback(new Error(util.format(
            'Response with status code %s.', response.statusCode
          )));
        }

        // Note that the third body argument and response.body will be garbage
        // strings at this point. You can't do anything with them. To get at the
        // response you have to use the streamed data in the buffers.
        zlib.gunzip(Buffer.concat(buffers), function (gunzipError, bodyBuffer) {
          if (gunzipError) {
            return asyncCallback(gunzipError);
          }

          asyncCallback(null, bodyBuffer.toString('utf-8'));
        });
      }
    );

    // Gather up the streamed compressed response into an array of buffers.
    req.on('data', function (buf) {
      buffers[buffers.length] = buf;
    });
  }, function (error, xml) {
    if (error) {
      return callback(error);
    }

    exports.xmlByYear[year] = libxmljs.parseXml(xml);

    fs.outputFile(
      filePath,
      xml,
      {
        encoding: 'utf-8'
      },
      callback
    );
  });
};

/**
 * Load the full year data as an XML string from the local cache or the
 * NVD site.
 *
 * @param {Number} year The year of the data.
 * @param {Function} callback Of the form function (error).
 */
exports.loadYearData = function (year, callback) {
  var filePath = exports.getLocalFeedFilePath(year);
  var options = {
    encoding: 'utf-8'
  };

  // Don't bother with the cache for this year's data - it gets updated on
  // a regular basis.
  if (year === (new Date()).getFullYear()) {
    return exports.downloadYearData(year, callback);
  }

  fs.readFile(filePath, options, function (error, xml) {
    // If this errors, that means no file, so go download it.
    if (error) {
      exports.downloadYearData(year, callback);
    }
    // We have a local cache, so use that.
    else {
      exports.xmlByYear[year] = libxmljs.parseXml(xml);
      callback();
    }
  });
};

/**
 * Obtain CVE data from the processed XML document.
 *
 * @param {String} cveId The CVE ID, e.g. CVE-2002-0001.
 * @param {Object} doc Processed libxmljs doc.
 * @return {Object} CVE data.
 */
exports.cveDataFromProcessedYearData = function (cveId, doc) {
  // The NVD doc is overly namespaced. So we need this to get anything done
  // with xpath in libxmljs.
  var namespaceIds = {
    // Have to specify the default and give it an id to get libxmljs happy.
    n: 'http://scap.nist.gov/schema/feed/vulnerability/2.0',
    // Use the prefixes in the doc for the rest.
    'cpe-lang': 'http://cpe.mitre.org/language/2.0',
    cvss: 'http://scap.nist.gov/schema/cvss-v2/0.2',
    patch: 'http://scap.nist.gov/schema/patch/0.1',
    'scap-core': 'http://scap.nist.gov/schema/scap-core/0.1',
    vuln: 'http://scap.nist.gov/schema/vulnerability/0.4'
  };

  var elem = doc.find(util.format(
    '/n:nvd/n:entry[@id=\'%s\']',
    cveId
  ), namespaceIds)[0];

  if (!elem) {
    return {
      id: cveId,
      summary: 'Not present in NVD data. Try clearing the local cache of XML files under the data directory.'
    }
  }

  var cvss = elem.find(
    'vuln:cvss/cvss:base_metrics/cvss:score',
    namespaceIds
  )[0];
  if (cvss) {
    cvss = cvss.text();
  }

  var summary = elem.find('vuln:summary', namespaceIds)[0];
  if (summary) {
    summary = summary.text();
  }

  return {
    id: cveId,
    cvss: cvss,
    summary: summary,
    url: exports.getCveUrl(cveId)
  };
};

/**
 * Get the data for a given CVE ID.
 *
 * @param {String} cveId The CVE ID, e.g. CVE-2002-0001.
 * @param {Function} callback Of the form function (error, data).
 */
exports.getDataForCveId = function (cveId, callback) {
  var year = exports.yearFromCveId(cveId);
  var xmldoc;

  /**
   * Helper function.
   */
  function callBackWithData () {
    exports.cveData[cveId] = exports.cveDataFromProcessedYearData(cveId, xmldoc);
    callback(null, exports.cveData[cveId]);
  }

  // Already processed?
  if (exports.cveData[cveId]) {
    return callback(null, exports.cveData[cveId]);
  }

  xmldoc = exports.xmlByYear[exports.yearFromCveId(cveId)];

  if (xmldoc) {
    return callBackWithData();
  }

  // We have to load the document since it isn't there already.
  exports.loadYearData(year, function (error) {
    if (error) {
      return callback(error);
    }

    xmldoc = exports.xmlByYear[year];
    callBackWithData();
  });
};
