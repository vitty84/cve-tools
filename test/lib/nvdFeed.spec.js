/**
 * @fileOverview Tests for lib/nvdFeed.
 */

// Core.
var path = require('path');
var util = require('util');
var zlib = require('zlib');

// NPM.
var fs = require('fs-extra');
var libxmljs = require('libxmljs');
var request = require('request');

// Local.
var nvdFeed = require('../../lib/nvdFeed');

describe('lib/nvdFeed', function () {
  var cveId;
  var cveData;
  var missingCveData;
  var missingCveId;
  var year;
  var encoding;
  var sandbox;
  var xmlFilePath;
  var xml;

  beforeEach(function () {
    sandbox = sinon.sandbox.create();

    missingCveId = 'CVE-2008-9999';
    missingCveData = {
      id: missingCveId,
      summary: 'Not present in NVD data. Try clearing the local cache of XML files under the data directory.'
    };

    cveId = 'CVE-2008-7312';
    cveData = {
      id: cveId,
      cvss: '5.0',
      summary: 'The Filtering Service in Websense Enterprise 5.2 through 6.3 does not consider the IP address during URL categorization, which makes it easier for remote attackers to bypass filtering via an HTTP request, as demonstrated by a request to a compromised server associated with a specific IP address.',
      url: nvdFeed.getCveUrl(cveId)
    };

    year = 2008;
    encoding = 'utf-8';
    xmlFilePath = path.resolve(__dirname, '../fixtures/nvdcve-2.0-2008.xml');
    xml = fs.readFileSync(xmlFilePath, { encoding: 'utf-8' });

    nvdFeed.xmlByYear = {};
    nvdFeed.cveData = {};
  });

  afterEach(function () {
    sandbox.restore();
  });

  describe('yearFromCveId', function () {
    it('functions as expected', function () {
      expect(nvdFeed.yearFromCveId(cveId)).to.equal(year);
    });
  });

  describe('getFeedFileName', function () {
    it('functions as expected', function () {
      expect(nvdFeed.getFeedFileName(year)).to.equal(util.format(
        'nvdcve-2.0-%d.xml',
        year
      ));
    });
  });

  describe('getFeedUrl', function () {
    it('functions as expected', function () {
      expect(nvdFeed.getFeedUrl(year)).to.equal(util.format(
        'https://nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-%d.xml.gz',
        year
      ));
    });
  });

  describe('getLocalFeedFilePath', function () {
    it('functions as expected', function () {
      expect(nvdFeed.getLocalFeedFilePath(year)).to.equal(
        path.resolve(__dirname, '../../data', nvdFeed.getFeedFileName(year)
      ));
    });
  });

  describe('getCveUrl', function () {
    it('functions as expected', function () {
      expect(nvdFeed.getCveUrl(cveId)).to.equal(
        'https://web.nvd.nist.gov/view/vuln/detail?vulnId=' + cveId
      );
    });
  });

  describe('downloadYearData', function () {
    var gzippedXml;
    var req;

    beforeEach(function (done) {
      zlib.gzip(xml, function (error, _gzippedXml) {
        gzippedXml = _gzippedXml;
        req = {
          on: sandbox.stub()
        };
        req.on.yields(gzippedXml);

        sandbox.stub(request, 'get').yieldsAsync(null, {});
        request.get.returns(req);

        sandbox.stub(fs, 'outputFile').yields();

        done();
      });
    });

    it('functions as expected', function (done) {
      nvdFeed.downloadYearData(year, function (error) {
        expect(nvdFeed.xmlByYear[year]).to.eql(libxmljs.parseXml(xml));

        sinon.assert.calledWith(
          request.get,
          nvdFeed.getFeedUrl(year),
          sinon.match.func
        );
        sinon.assert.calledWith(
          fs.outputFile,
          nvdFeed.getLocalFeedFilePath(year),
          xml,
          {
            encoding: encoding
          },
          sinon.match.func
        );

        done(error);
      });
    });

    it('retries on error', function (done) {
      request.get.onCall(0).yieldsAsync(new Error());
      request.get.onCall(0).returns(req);

      nvdFeed.downloadYearData(year, function (error) {
        expect(nvdFeed.xmlByYear[year]).to.eql(libxmljs.parseXml(xml));

        sinon.assert.callCount(request.get, 2);
        sinon.assert.alwaysCalledWith(
          request.get,
          nvdFeed.getFeedUrl(year),
          sinon.match.func
        );
        sinon.assert.calledWith(
          fs.outputFile,
          nvdFeed.getLocalFeedFilePath(year),
          xml,
          {
            encoding: encoding
          },
          sinon.match.func
        );

        done(error);
      });
    });
  });

  describe('loadYearData', function () {

    beforeEach(function () {
      sandbox.stub(nvdFeed, 'downloadYearData').yields();
      sandbox.stub(fs, 'readFile').yields(null, xml);
      sandbox.stub(fs, 'writeFile').yields();
    });

    it('loads from file, saves to xmlByYear', function (done) {
      nvdFeed.loadYearData(year, function (error) {
        expect(nvdFeed.xmlByYear[year]).to.eql(libxmljs.parseXml(xml));

        sinon.assert.calledWith(
          fs.readFile,
          nvdFeed.getLocalFeedFilePath(year),
          {
            encoding: encoding
          },
          sinon.match.func
        );
        sinon.assert.notCalled(nvdFeed.downloadYearData);
        sinon.assert.notCalled(fs.writeFile);

        done(error);
      });
    });

    it('downloads when no file', function (done) {
      fs.readFile.yields(new Error());

      nvdFeed.loadYearData(year, function (error) {
        sinon.assert.calledWith(
          fs.readFile,
          nvdFeed.getLocalFeedFilePath(year),
          {
            encoding: encoding
          },
          sinon.match.func
        );
        sinon.assert.calledWith(
          nvdFeed.downloadYearData,
          year,
          sinon.match.func
        );

        done(error);
      });
    });

    it('always downloads for this year', function (done) {
      year = (new Date()).getFullYear();

      nvdFeed.loadYearData(year, function (error) {
        sinon.assert.notCalled(fs.readFile);
        sinon.assert.calledWith(
          nvdFeed.downloadYearData,
          year,
          sinon.match.func
        );

        done(error);
      });
    });
  });

  describe('cveDataFromProcessedYearData', function () {
    var doc;

    beforeEach(function () {
      doc = libxmljs.parseXml(xml);
    });

    it('functions as expected', function () {
      expect(nvdFeed.cveDataFromProcessedYearData(cveId, doc)).to.eql(cveData);
    });

    it('returns stub for missing data', function () {
      expect(nvdFeed.cveDataFromProcessedYearData(missingCveId, doc)).to.eql(
        missingCveData
      );
    });
  });

  describe('getDataForCveId', function () {
    var xmldoc;

    beforeEach(function () {
      xmldoc = libxmljs.parseXml(xml);

      sandbox.stub(fs, 'mkdirs').yields();
      sandbox.stub(nvdFeed, 'loadYearData', function (year, callback) {
        nvdFeed.xmlByYear[year] = xmldoc;
        callback();
      });
    });

    it('functions as expected with no initial data', function (done) {
      nvdFeed.getDataForCveId(cveId, function (error, data) {
        expect(data).to.eql(cveData);

        sinon.assert.calledWith(
          nvdFeed.loadYearData,
          year,
          sinon.match.func
        );

        done(error);
      });
    });

    it('calls back with stub for missing data', function (done) {
      nvdFeed.getDataForCveId(missingCveId, function (error, data) {
        expect(data).to.eql(missingCveData);

        sinon.assert.calledWith(
          nvdFeed.loadYearData,
          year,
          sinon.match.func
        );

        done(error);
      });
    });

    it('skips load for existing processed data', function (done) {
      nvdFeed.cveData[cveId] = {};

      nvdFeed.getDataForCveId(cveId, function (error, data) {
        expect(data).to.equal(nvdFeed.cveData[cveId]);

        sinon.assert.notCalled(nvdFeed.loadYearData);

        done(error);
      });
    });

    it('skips load for existing year document', function (done) {
      nvdFeed.xmlByYear[year] = xmldoc;

      nvdFeed.getDataForCveId(cveId, function (error, data) {
        expect(data).to.eql(cveData);

        sinon.assert.notCalled(nvdFeed.loadYearData);

        done(error);
      });
    });

  });
});
